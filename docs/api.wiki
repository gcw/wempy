<h2>API (basics)</h2>

The wempy templates API is very simple. After the package is installed you can simply import and invoke the <em>TemplateParser</em> Class as you see fit:

<verbatim>
>>> import wemplate.wemplate
>>> T = wemplate.wemplate.TemplateParser("Sample Template {{=str(3*7)}}")
</verbatim>

or 

<verbatim>
>>> from wemplate.wemplate import TemplateParser
>>> T = TemplateParser("Sample Template {{=str(3*7)}}")
</verbatim>

In either case you now have a TemplateParser object 'T' which can be used as
such. To render the parsed template with out additional context elements simply call T.render():

<verbatim>
>>> T.render()
'Sample Template 21'
</verbatim>

To view the script generated by the template simply call T.to_string() or use the str() function on the TemplateParser object instance:
<verbatim>
>>> T.to_string()
"import sys\nsys.stdout.write('Sample Template ')\nsys.stdout.write(str(3*7))"
>>> str(T)
"import sys\nsys.stdout.write('Sample Template ')\nsys.stdout.write(str(3*7))"
>>> print str(T)
import sys
sys.stdout.write('Sample Template ')
sys.stdout.write(str(3*7))
</verbatim>

If you want to set some context for the template you can do so on invocation of
render(). Let's use a more apt example:

<verbatim>
>>> from wemplate.wemplate import TemplateParser
>>> text = "{{=singer}} has an interesting relationship with a man"
>>> T = TemplateParser(text)
</verbatim>

If we invoke render() with no explicit contextual additions, we get an error because 'singer' isn't defined for the TemplateParser instance:
<verbatim>
>>> T.render()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/gcw/.pythonbrew/pythons/Python-2.7.3/lib/python2.7/site-packages/wemplate/wemplate.py", line 844, in render
    exec(code, temp_context) 
  File "<string>", line 2, in <module>
NameError: name 'singer' is not defined
</verbatim>

We can pass a dictionary to define our context for the template:

<verbatim>
>>> my_context = dict(singer='Marla')
>>> T.render(my_context)
'Marla has an interesting relationship with a man'
</verbatim>

Dictionaries are great for defining a number of elements ahead of time but sometimes it's easier to pass individual assignments:

<verbatim>
>>> T.render(singer = 'Marla')
'Marla has an interesting relationship with a man'
</verbatim>

Whether you use individual assignments or a dictionary (like) object, you can call render() successively with different contexts:

<verbatim>
>>> T.render(singer = 'Andrew')
'Andrew has an interesting relationship with a man'
>>> T.render(singer = 'Kevin')
'Kevin has an interesting relationship with a man'
>>> T.render(singer = 'Walker')
'Walker has an interesting relationship with a man'
</verbatim>

